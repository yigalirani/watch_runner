{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["\nimport { spawn } from 'node:child_process';\nimport { watch } from 'node:fs';\ntype FilterFunc=(line:string)=>string|true|false //string-show just the string  +line number, true show as is, false dont show\n\nexport const eslint_linting_code:FilterFunc=(line:string)=>{\n  if (line.split(' eslintrc:').length>1)\n    return false\n  const split=line.split(' eslint:')[1]//Linting code for ');\n  if (split==null)\n    return true\n  const split2=split.split('Linting code for ')[1]\n  if (split2==null)\n    return false\n  return split2\n}\nfunction waitForAbort(controller: AbortController): Promise<void> {\n  const { signal } = controller;\n  controller.abort()\n  return new Promise<void>((resolve) => {\n    if (signal.aborted) {\n      resolve();\n      return;\n    }\n    signal.addEventListener('abort', () => resolve(), { once: true });\n  });\n}\nclass WorkerListenr{\n  start_time:number=0\n  last_line=''\n  count=0\n  filter:FilterFunc\n  start_message:string\n  constructor(filter:FilterFunc,start_message:string){\n    this.filter=filter\n    this.start_message=start_message\n  }\n  print_filtered(line:string){\n    const filtered=this.filter(line)\n    if (filtered===false)\n      return \n    if (filtered===true){\n      console.log(line)\n      return \n    }\n    console.log(this.count++,filtered)\n  }  \n  start(){\n    process.stdout.write('\\x1Bc'); //clear screen\n    console.log(this.start_message,'=================================================================')\n    this.start_time=Date.now()\n  }\n  elapsed(){\n    return `elapsed=${Date.now()-this.start_time}ms`\n  }\n  flush(){\n    this.print_filtered(this.last_line)\n  }\n  close(code:number|null){\n    this.flush()\n    console.warn(`exited,code=${code},${this.elapsed()}`);\n  }\n  error(err:unknown){\n    this.flush()\n    console.warn(`failed,err=${err},${this.elapsed()}`);\n  }\n  data(a:string){\n    const total_text=this.last_line+a\n    const lines=total_text.split('\\n')\n    for (const  line of lines.slice(0,-1))\n      this.print_filtered(line)\n  \n    this.last_line=lines.at(-1)||''\n  }\n}\n\nfunction allways_true(_a:string){\n  return true\n}\n\nfunction run_cmd({\n  cmd,\n  worker_listener\n}: {\n  cmd: string;\n  worker_listener:WorkerListenr\n}):AbortController {\n  const ans=new AbortController()\n  const {signal}=ans\n  void new Promise((resolve, _reject) => { \n  \n    const child = spawn(cmd, {\n      signal,\n      shell: true,\n      env: { ...process.env, FORCE_COLOR: \"1\" },  \n    });\n    child.on('spawn',()=>worker_listener.start())\n    child.stdout.on(\"data\", (data:unknown) => worker_listener.data(String(data)))\n    child.stderr.on(\"data\", (data:unknown) => worker_listener.data(String(data)))\n    child.on(\"close\", (code) => {\n      worker_listener.close(code)\n      resolve(null);\n    });\n\n    child.on(\"exit\", (err) => {\n      worker_listener.error(err)\n      resolve(null);\n    });\n    child.on(\"error\", (err) => {\n      worker_listener.error(err)\n      resolve(null);\n    });\n  });\n  return ans\n}\n\nexport  async function run({cmd,title,watchfiles=[],filter=allways_true}:{\n  cmd:string|(()=>Promise<void>)\n  title?:string\n  watchfiles?:string[]\n  filter?:FilterFunc\n}){\n  const effective_title=function(){\n    if (title!=null)\n      return title\n    if (typeof cmd==='string')\n      return cmd\n    return ''\n  }()\n  let last_run=0\n  let last_changed=0\n  let filename_changed=''\n  function runit(reason:string){\n    last_run=Date.now()\n    let controller=new AbortController()\n    const worker_listener=new WorkerListenr(filter,`starting ${effective_title||''}: ${reason}`)\n    try{\n      if (typeof cmd==='string')\n        controller=run_cmd({cmd:cmd,worker_listener})\n      else\n        console.log('todo: run function')\n        //await cmd()\n    }catch(ex){\n      worker_listener.error(ex)  \n      //console.log(`failed ${effective_title||''} ${duration} ms: ${String(ex)}`)      \n    }\n    return controller\n  }\n  let controller=runit('initial')\n  for (const filename of watchfiles){\n    watch(filename,{},(eventType, changed_file) => {\n      const changed=`changed: ${filename}/${changed_file} `\n      console.log(changed);\n      last_changed=Date.now()\n      filename_changed=changed\n    }) \n  }\n  while (true) { \n    //console.log('loop',last_changed , last_run,last_changed > last_run)\n    if (last_changed > last_run) {  \n      await waitForAbort(controller)\n      controller= runit(filename_changed)\n    }\n    await new Promise(r => setTimeout(r, 1000)); // wait 1s before next iteration\n  }  \n}\n"],
  "mappings": "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",
  "names": ["controller"]
}
